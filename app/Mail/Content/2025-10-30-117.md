---
title: 'My wishlist for PHP in 2026'
pretext: "I would say I've kept it pretty tame, no?"
---

Hi ::subscriber.first_name::

If you want to, you can [read this post on my blog](https://stitcher.io/blog/my-wishlist-for-php-in-2026) as well, whatever works best for you :)

As we near the end of 2025, I thought it was a good time to reflect on my wishlist for PHP. I've done so a couple of times before. I'm happy I've been able to scratch a couple of items off those lists because they actually made it into the language by now:

- [Named parameters](https://stitcher.io/blog/php-8-named-arguments)
- [Improved type variance](https://stitcher.io/blog/new-in-php-74#improved-type-variance-rfc)
- [Enums](https://stitcher.io/blog/php-enums)
- [The pipe operator](https://stitcher.io/blog/pipe-operator-in-php-85)

But. There is more. Interestingly enough, my wishlist has been changing for the past year. Of course some of the same things are still on there (yes, generics, no suprise); but I've also let go of some things, and added others. Let's take a look!

## PHP Editions

Because of PHP's backwards compatibility promise, new features have to be perfect: once they are added into the language, they are there to stay. That's one of the reasons features take so long to add and often end up full of compromise, because internals try to foresee all the edge cases. The most recent example is the new [URI extension](https://thephp.foundation/blog/2025/10/10/php-85-uri-extension/#thoughtfully-built-to-last):

> Thus, over the course of almost one year, more than 150 emails on the PHP Internals list were sent. Additionally, several off-list discussions in various chat rooms have been had.

Almost a whole year was spent on a relatively small feature. On top of that: no one is perfect, and things will have been overlooked.

PHP would benefit from having opt-in features: a way to enable a specific feature only within a specific namespace. That way PHP could introduce new features that broke backwards compatibility, without actually affecting any existing code. It could reduce the need for "getting it perfect" if they had some kind of "experimental feature" opt-in as well: a stage where breaking changes would still be allowed. 

In other words: you could update to the latest PHP version, and only enable breaking changes for a part of your codebase (likely your own project code), but leave vendor code unaffected by it. Maybe the syntax would look something like this:

```php
namespace Tempest
{
    declare({:hl-property:edition:}=8_5);
}

namespace App
{
    declare({:hl-property:edition:}=experimental);
}
```

There is a lot to unpack about this topic, and I plan to write a followup-post about it soon. I do want to mention that I'm not pulling this idea out of thin air: Nikita actually proposed to add [PHP editions](https://externals.io/message/106453#106454) years ago, which in turn was based on [Rust Editions](https://doc.rust-lang.org/edition-guide/editions/index.html):

> I think that introducing this kind of concept for PHP is very, very important. We have a long list of issues that we cannot address due to backwards compatibility constraints and will never be able to address, on any timescale, without having the ability of opt-in migration.
> I do plan to create an RFC on this topic.

Unfortunately, Nikita has since left PHP, and that RFC never came to fruition.

## Interface default methods

Of all my wishlist items, I'm most hopeful this one might actually happen some day. There has already been [an RFC](https://wiki.php.net/rfc/interface-default-methods) for it in the past, and some internals have expressed interest in doing a second attempt at it.

The idea is to allow interfaces to provide a default implementation, right within the interface itself:

```php
interface Request
{
    // â€¦
    
    public array $query {
        get;
    }
    
    public function hasQuery(string $key): bool
    {
        return has_key($this->query, $key);
    }
}
```

Classes implementing this interface can override the default implementation, but they don't have to if they don't need to. But hang on â€” this is what abstract classes are for, no? In a way, yes, but there are some important differences between interfaces and abstract classes:

- You can only inherit from one abstract class, while you can implement multiple interfaces; and
- interfaces usually stand on their own, while deep inheritance chains with abstract classes are a much more common occurrence.

These two factors combined make interfaces much more lightweight and flexible compared to abstract classes, and that is why I prefer to use interfaces. Abstract classes simply get a too tight a grip on my codebase, it feels like they are almost "chocking" my code, and I don't like that.

One classic example of abstract classes failing is model classes in Laravel:

```php
class BlogPost extends Model { /* â€¦ */ }

class NewsBlogPost extends Model { /* â€¦ */ }

class GuestBlogPost extends Model { /* â€¦ */ }
```

Personally, I would like to model `{php}NewsBlogPost` and `{php}GuestBlogPost` as subtypes of `{php}BlogPost`, so that I could leverage the benefits mentioned before: code reuse and polymorphism. However, my code has to be tightly coupled to `{php}Model`, because otherwise it couldn't work with Laravel's ORM. From my perspective, a `{php}NewsBlogPost` isn't a `{php}Model`, it just happens to be compatible with the technical expectations the framework has defined of what "a model should look like". 

And that's what interfaces are better at representing:

```php
class BlogPost implements Model { /* â€¦ */ }

class NewsBlogPost extends BlogPost { /* â€¦ */ }

class GuestBlogPost extends BlogPost { /* â€¦ */ }
```

However, the downside with PHP is that an interface has no way of providing an implementation, and you end up having to reimplement all `{php}Model` specific methods whenever you implement it. PHP has a workaround of some sorts, to use traits:

```php
class BlogPost implements Model 
{ 
    use IsModel;
}
```

You know, this works, but it's not suuuuuuper convenient. And that's why I want interface default methods :)

Sidenote: we could achieve the same result if traits could be used to represent types. Technically this is impossible because of how traits are a compile-time copy/paste mechanism, but if people find it easier to accept "type hints on traits" over "interface default methods", then I'm totally ok with that approach as well:

```php
class BlogPost 
{ 
    use Model;
}
```

## Generics

Ohâ€¦ Generics ðŸ¥¹. [What](https://stitcher.io/blog/php-generics-and-why-we-need-them) [can](https://www.youtube.com/watch?v=ffhhx5_TUB8) [I say](https://stitcher.io/blog/generics-in-php-1) [that](https://stitcher.io/blog/generics-in-php-video) [hasn't](https://stitcher.io/blog/generics-in-php-2) [been](https://stitcher.io/blog/generics-in-php-3) [said](https://stitcher.io/blog/generics-in-php-4) [before](https://stitcher.io/blog/the-case-for-transpiled-generics)? 

The good news is that the Foundation was still [looking into them](https://thephp.foundation/blog/2024/08/19/state-of-generics-and-collections/) this year. The bad news is that they came to the conclusion (again) that runtime generics are a bad idea. The better news is that generics conceptually are a compile-time tool so we don't even need runtime checks. The worst news is that considering runtime-ignored generics requires a mind shift within PHP that is unlikely to happen. 

But, who knows â€” maybe one day. I'll dream. We're getting close to Christmas, after all.

```php
$query = new ModelQuery<{:hl-generic:Post:}>;
```

## Structs

My final wishlist item (I'm keeping it pretty down-to-earth, don't you think?) is structs. I wrote a post about [my struggles with `private(set)` and `readonly`](https://stitcher.io/blog/readonly-or-private-set) and came to the conclusion thatâ€¦ much of my struggles would be solved if only PHP had simple structsâ€¦

```txt
{:hl-keyword:struct:} {:hl-type:Book:}
{
    {:hl-type:string:} {:hl-property:$title:};
    {:hl-type:Author:} {:hl-property:$author:};
    {:hl-type:ChapterCollection:} {:hl-property:$chapters:};
    {:hl-type:Publisher:} {:hl-property:$publisher:};
    {:hl-type:null|DateTimeImmutable:} {:hl-property:$publishedAt:} = {:hl-keyword:null:};
}
```

Look, at the end of the day: I just want a simple way to represent data in a structured manner. I think it's a widespread use case and should be fairly straight-forward to add. 

## Things I scratched

I mentioned I had scratched a couple of things from my list as well. For example, I wanted **scalar objects** so that you could write something like this:

```php
$string = ' hello, world '; 

echo $string->trim()->explode(',');
```

Look, I still want them; they would be nice. However, I simply think the scope of such a feature is too large to ever make it through [PHP's committee](https://stitcher.io/blog/limited-by-committee) in a reasonable way. Meanwhile, we have many userland implementations that are a tiny bit more verbose but do the job. I'm ok with that.

I also wanted **unified functions names and signatures**, but that's just never happening. Actually, having PHP editions might open the door for this refactor, but even then do I have my doubts. I've come to accept PHP's quirkiness. 

Finally, there was **clone with**. Whichâ€¦ we will actually get in PHP 8.5, but not in a way that solves [the issue I hoped it would solve](https://stitcher.io/blog/readonly-or-private-set). So, yeah. I think that ship has sailed? 

However, let's focus on the things that might still happen. I think editions are the key to solving many problems in PHP, and I hope someone will put it back on the table in 2026! Don't hesitate to hit reply to share your thoughts and personal wishlist items with me as well. I'm looking forward hearing from you!

Until next time

Brent