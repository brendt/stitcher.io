Today, we're building a procedurally generated, 2D game with PHP. It's a simple game that's focussed around resource gathering on a procedurally generated map. In case you're unfamiliar with that term: it's a map there's generated by code, based on a seed. Every seed will generate a completely unique map. It looks something like this: 

![](/resources/img/blog/game/game-1.png)

So, how do we go from plain PHP to a map like this? It all starts with noise.

## Noise generation

Let's imagine we have grid of 150 by 100 pixels. Each pixel makes up a point of our map.

```php
$pixels = [];

for($x = 0; $x < 150; $x++) {
    for($y = 0; $y < 100; $y++) {
        $pixels[$x][$y] = <hljs prop>drawPixel</hljs>($x, $y, 0); 
    }
}
```

For now, the `<hljs prop>drawPixel</hljs>` function will generate a `<hljs keyword>div</hljs>` per pixel, which can be laid out on a CSS grid. We can refactor to use `<hljs keyword>canvas</hljs>` later, but being able to use CSS's built-in grid saves a lot of time.

```php
function drawPixel(<hljs type>int</hljs> $x, <hljs type>int</hljs> $y): string
{
    <hljs keyword>return</hljs> <<<HTML
    <<hljs keyword>div</hljs> <hljs prop>style</hljs>="--x: {$x}; --y: {$y};"></<hljs keyword>div</hljs>>
    HTML;
}
```

This is the template file: 

```blade
<<hljs keyword>style</hljs>>
    :<hljs keyword>root</hljs> {
        <hljs prop>--pixel-size</hljs>: 9px;
        <hljs prop>--pixel-gap</hljs>: 1px;
        <hljs prop>--pixel-color</hljs>: #000;
    }

    .<hljs keyword>map</hljs> {
        <hljs prop>display</hljs>: grid;
        <hljs prop>grid-template-columns</hljs>: <hljs prop>repeat</hljs>({{ count($pixels) }}, var(--pixel-size));
        <hljs prop>grid-auto-rows</hljs>: <hljs prop>var</hljs>(--pixel-size);
        <hljs prop>grid-gap</hljs>: <hljs prop>var</hljs>(--pixel-gap);
    }

    .<hljs keyword>map</hljs> > <hljs keyword>div</hljs> {
        <hljs prop>width</hljs>: <hljs prop>var</hljs>(--pixel-size);
        <hljs prop>height</hljs>: 100%;
        <hljs prop>grid-area</hljs>: <hljs prop>var</hljs>(--y) / <hljs prop>var</hljs>(--x) / <hljs prop>var</hljs>(--y) / <hljs prop>var</hljs>(--x);
        <hljs prop>background-color</hljs>: <hljs prop>var</hljs>(--pixel-color);
    }
</<hljs keyword>style</hljs>>

<<hljs keyword>div</hljs> <hljs prop>class</hljs>="map">
    @<hljs keyword>foreach</hljs>($pixels as $x => $row)
        @<hljs keyword>foreach</hljs>($row as $y => $pixel)
            {!! $pixel !!}
        @<hljs keyword>endforeach</hljs>
    @<hljs keyword>endforeach</hljs>
</<hljs keyword>div</hljs>>
```

This is the result:

![](/resources/img/blog/game/game-20.png)

By the way, I will get rid of the gaps between pixels, I only added them to show that these are indeed separate grid cells.

Let's play around with our grid. We'll start by assigning a value between 0 and 1 for each individual pixel. We'll use a class called `<hljs type>Noise</hljs>` that takes a pixel's point (X/Y coordinates), and returns a value for that point. First, we'll return a random value.

```php
final <hljs keyword>readonly</hljs> class Noise
{
    public function __construct(
        <hljs keyword>private</hljs> <hljs type>int</hljs> <hljs prop>$seed</hljs>,
    ) {}
    
    public function generate(<hljs type>Point</hljs> $point): float
    {
        return <hljs prop>rand</hljs>(1, 100) / 100;
    }
}

// …

<hljs prop>drawPixel</hljs>($x, $y, $noise-><hljs prop>generate</hljs>($x, $y)); 
```

Here's the result:

![](/resources/img/blog/game/game-2.png)

Relying on randomness won't get us very far though. We want a given seed to generate the same map over and over again. So instead of randomness, let's write a hash function: a function that, for any given point and seed, will generate the same value over and over again. You could make it as simple as multiplying the seed with the x and y coordinates, and turning that into a fraction:

```php
public function generate(<hljs type>Point</hljs> $point): float
{
    $hash = $this-><hljs prop>seed</hljs> * $point-><hljs prop>x</hljs> * $point-><hljs prop>y</hljs>;
    
    return <hljs prop>floatval</hljs>('0.' . $hash);
}
```

The result, however, doesn't seem random enough. Remember that we want to generate a world map: we want some randomness, but also some cohesion. So our hash function will need to be a bit more complex.

![](/resources/img/blog/game/game-3.png)

Let's try an existing hash function that we don't need to invent ourselves. We probably want a performant one, since we're generating a hash for thousands of pixels. PHP has support for xxHash, which is an "extremely fast hashing algorithm". Let's give it a try.

```php
private function <hljs prop>hash</hljs>(<hljs type>Point</hljs> $point): float
{
    $hash = <hljs prop>bin2hex</hljs>(
        <hljs prop>hash</hljs>(
            <hljs prop>algo</hljs>: 'xxh32',
            <hljs prop>data</hljs>: $this-><hljs prop>seed</hljs> * $point-><hljs prop>x</hljs> * $point-><hljs prop>y</hljs>,
        )
    );

    $hash = <hljs prop>floatval</hljs>('0.' . $hash);

    return $hash;
}
```

![](/resources/img/blog/game/game-4.png)

This noise looks promising: it's quite random, but always yields the same result for a given seed. But going from this to a cohesive world map still seems like a leap. Let's change our hash function, so that it'll return the same color within a square of 10 pixels:

```php
private function <hljs prop>hash</hljs>(<hljs type>Point</hljs> $point): float
{
    $baseX = <hljs prop>ceil</hljs>($point-><hljs prop>x</hljs> / 10);
    $baseY = <hljs prop>ceil</hljs>($point-><hljs prop>y</hljs> / 10);

    $hash = <hljs prop>bin2hex</hljs>(
        <hljs prop>hash</hljs>(
            <hljs prop>algo</hljs>: 'xxh32',
            <hljs prop>data</hljs>: $this-><hljs prop>seed</hljs> * $baseX * $baseY,
        )
    );

    $hash = <hljs prop>floatval</hljs>('0.' . $hash);

    return <hljs prop>sqrt</hljs>($hash);
}
```

Here's the result:

![](/resources/img/blog/game/game-6.png)

Oh, by the way: I take the square root of the hash, just to increase all values a little bit. That'll be useful in the future, but not necessary. Without the square root, the map looks like this:

![](/resources/img/blog/game/game-5.png)

Let's _imagine_ something for a second. Let's say all pixels with a value higher than 0.6 are considered land, and all pixels with a lower value are considered water. Let's make some changes to our `<hljs prop>drawPixel</hljs>` method to reflect that behaviour:

```php
function drawPixel(<hljs type>int</hljs> $x, <hljs type>int</hljs> $y, <hljs type>float</hljs> $value): string
{
    $hexFromNoise = <hljs prop>hex</hljs>($value);
    
    $color = <hljs keyword>match</hljs>(<hljs keyword>true</hljs>) {
        $noise < 0.6 => "#0000{$hexFromNoise}", // blue
        <hljs keyword>default</hljs> => "#00{$hexFromNoise}00", // green
    };
    
    <hljs keyword>return</hljs> <<<HTML
    <<hljs keyword>div</hljs> <hljs prop>style</hljs>="<hljs prop>--x</hljs>: {$x}; <hljs prop>--y</hljs>: {$y}; <hljs prop>--pixel-color</hljs>: {$color}"></<hljs keyword>div</hljs>>
    HTML;
}
```

By the way, that `<hljs prop>hex</hljs>` function converts a value between 0 and 1 to a two-digit hexadecimal. It looks like this:

```php
function <hljs prop>hex</hljs>(<hljs type>float</hljs> $value): <hljs type>string</hljs>
{
    if ($value > 1.0) {
        $value = 1.0;
    }

    $hex = <hljs prop>dechex</hljs>((<hljs type>int</hljs>) ($value * 255));

    if (<hljs prop>strlen</hljs>($hex) < 2) {
        $hex = "0" . $hex;
    }

    return $hex;
}

```

The result is looking a lot more like a map already:

![](/resources/img/blog/game/game-7.png)

Ok, pretty nice! But these sharp edges don't really look realistic. Can we find a way to make transitions between the edges more smooth?

## Lerp

Time for some maths. Let's say we have two values: `0.34` and `0.78`. We want to know the value exactly in the middle between these two. How do we do that? 

![](/resources/img/blog/game/game-8.png)

Well, there's a simple mathematical formula for that. It's called "Linear Interpolation" — "LERP" for short:

```php
function <hljs prop>lerp</hljs>(<hljs type>float</hljs> $a, <hljs type>float</hljs> $b, <hljs type>float</hljs> $fraction): float
{
    return $a + $fraction * ($b - $a);
}

<hljs prop>lerp</hljs>(0.34, 0.78, 0.5); // 0.56
```

So, given a number `$a` (`0.34`), a number `$b` (`0.78`), and a fraction (`0.5`, also known as: "half"); we get `0.56` — the number exactly in the middle between `0.34` and `0.78`.

![](/resources/img/blog/game/game-9.png)

Thanks to the _fraction_ part in our lerp formula, we can determine the value at _any place_ between these points, not just the middle:

```php
<hljs prop>lerp</hljs>(0.34, 0.78, 0.25); // 0.45
```

![](/resources/img/blog/game/game-10.png)

Ok, so why is this important? Well, we can use our lerp function to smooth edges! Let go back to our noise pattern and explain:


![](/resources/img/blog/game/game-6.png)

Let's say that, instead of coloring each pixel in this grid, we only color a pixel when it's exactly on a 10x10 lattice. In other words: when its x and y coordinates are divisible by 10.

```php
final <hljs keyword>readonly</hljs> class Noise
{
    public function generate(<hljs type>Point</hljs> $x): float
    {
        if ($point-><hljs prop>x</hljs> % 10 === 0 && $point-><hljs prop>y</hljs> % 10 === 0) {
            return $this-><hljs prop>hash</hljs>($point);
        } else {
            return 0.0;
        }
    }

    // …
}
```

Here's the lattice:

![](/resources/img/blog/game/game-11.png)

Let's imagine that these pixels are the `$a` and `$b` boundaries we pass into our lerp function. For any given pixel, it's trivial to determine these surrounding "fixed" points (they are on a fixed 10x10 grid) and we can also calculate the pixel's relative distance to those points. We can use the hash of these fixed points and the distance from any pixel to these points as input values for our lerp function. The result will be a value that's somewhere between the values of our two edge points — in other words: a smooth transition.

![](/resources/img/blog/game/game-21.png)

First, we'll use our lerp function on the y-axis (whenever x is divisible by 10). We'll determine the relative top and bottom points on our "lattice", calculate the distance between our current point and the top point, and then we'll use our lerp function to determine the right value between the top and bottom point, with that distance fraction: 

```php
if ($point-><hljs prop>x</hljs> % 10 === 0 && $point-><hljs prop>y</hljs> % 10 === 0) {
    $noise = $this-><hljs prop>hash</hljs>($point);
} elseif ($point-><hljs prop>x</hljs> % 10 === 0) {
    $topPoint = new <hljs type>Point</hljs>(
        <hljs prop>x</hljs>: $point-><hljs prop>x</hljs>,
        <hljs prop>y</hljs>: (<hljs prop>floor</hljs>($point-><hljs prop>y</hljs> / 10) * 10), 
        // The closest point divisible by 10, above our current pixel
    );

    $bottomPoint = new <hljs type>Point</hljs>(
        <hljs prop>x</hljs>: $point-><hljs prop>x</hljs>, 
        <hljs prop>y</hljs>: (<hljs prop>ceil</hljs>($point-><hljs prop>y</hljs> / 10) * 10) 
        // The closest point divisible by 10, below our current pixel
    );

    $noise = <hljs prop>lerp</hljs>(
        // The hash value (or color) of that top point:
        <hljs prop>a</hljs>: $this-><hljs prop>hash</hljs>($topPoint),
        
        // The hash value (or color) of that bottom point:
        <hljs prop>b</hljs>: $this-><hljs prop>hash</hljs>($bottomPoint),
        
        // The distance between our current point and the top point
        // — the fraction
        <hljs prop>fraction</hljs>: ($point-><hljs prop>y</hljs> - $topPoint-><hljs prop>y</hljs>) / ($bottomPoint-><hljs prop>y</hljs> - $topPoint-><hljs prop>y</hljs>),
    );
}
```

Here's the result, you can already see the smooth transition within the lines:

![](/resources/img/blog/game/game-12.png)

Next, let's add the same functionality in the other direction, when y is divisible by 10:

```php
if ($point-><hljs prop>x</hljs> % 10 === 0 && $point-><hljs prop>y</hljs> % 10 === 0) {
    // …
} elseif ($point-><hljs prop>x</hljs> % 10 === 0) {
    // …
} elseif ($point-><hljs prop>y</hljs> % 10 === 0) {
    $leftPoint = new <hljs type>Point</hljs>(
        <hljs prop>x</hljs>: (<hljs prop>floor</hljs>($point-><hljs prop>x</hljs> / 10) * 10),
        <hljs prop>y</hljs>: $point-><hljs prop>y</hljs>,
    );

    $rightPoint = new <hljs type>Point</hljs>(
        <hljs prop>x</hljs>: (<hljs prop>ceil</hljs>($point-><hljs prop>x</hljs> / 10) * 10),
        <hljs prop>y</hljs>: $point-><hljs prop>y</hljs>,
    );

    $noise = <hljs prop></hljs><hljs prop>lerp</hljs>(
        $this-><hljs prop></hljs><hljs prop>hash</hljs>($leftPoint),
        $this-><hljs prop></hljs><hljs prop>hash</hljs>($rightPoint),
        ($point-><hljs prop></hljs><hljs prop>x</hljs> - $leftPoint-><hljs prop></hljs><hljs prop>x</hljs>) / ($rightPoint-><hljs prop>x</hljs> - $leftPoint-><hljs prop>x</hljs>),
    );
}
```

No surprises:

![](/resources/img/blog/game/game-13.png)

Finally, for the remainder of the pixels, we won't be able to do a simple lerp function (which only works in one dimension). We'll have to use Bilinear Interpolation: we'll first make two lerp values for both x-axes, and then one final lerp value for the y-axis. We'll also need four edge points instead of two, because these pixels aren't aligned with our lattice.


![](/resources/img/blog/game/game-29.png)

```php
if ($point-><hljs prop>x</hljs> % 10 === 0 && $point-><hljs prop>y</hljs> % 10 === 0) {
    // …
} elseif ($point-><hljs prop>x</hljs> % 10 === 0) {
    // …
} elseif ($point-><hljs prop>y</hljs> % 10 === 0) {
    // …
} else {
    $topLeftPoint = new <hljs type>Point</hljs>(
        <hljs prop>x</hljs>: (<hljs prop>floor</hljs>($point-><hljs prop>x</hljs> / 10) * 10),
        <hljs prop>y</hljs>: (<hljs prop>floor</hljs>($point-><hljs prop>y</hljs> / 10) * 10),
    );

    $topRightPoint = new <hljs type>Point</hljs>(
        <hljs prop>x</hljs>: (<hljs prop>ceil</hljs>($point-><hljs prop>x</hljs> / 10) * 10),
        <hljs prop>y</hljs>: (<hljs prop>floor</hljs>($point-><hljs prop>y</hljs> / 10) * 10),
    );

    $bottomLeftPoint = new <hljs type>Point</hljs>(
        <hljs prop>x</hljs>: (<hljs prop>floor</hljs>($point-><hljs prop>x</hljs> / 10) * 10),
        <hljs prop>y</hljs>: (<hljs prop>ceil</hljs>($point-><hljs prop>y</hljs> / 10) * 10)
    );

    $bottomRightPoint = new <hljs type>Point</hljs>(
        <hljs prop>x</hljs>: (<hljs prop>ceil</hljs>($point-><hljs prop>x</hljs> / 10) * 10),
        <hljs prop>y</hljs>: (<hljs prop>ceil</hljs>($point-><hljs prop>y</hljs> / 10) * 10)
    );

    $a = <hljs prop>lerp</hljs>(
        $this-><hljs prop>hash</hljs>($topLeftPoint),
        $this-><hljs prop>hash</hljs>($topRightPoint),
        ($point-><hljs prop>x</hljs> - $topLeftPoint-><hljs prop>x</hljs>) / ($topRightPoint-><hljs prop>x</hljs> - $topLeftPoint-><hljs prop>x</hljs>),
    );

    $b = <hljs prop>lerp</hljs>(
        $this-><hljs prop>hash</hljs>($bottomLeftPoint),
        $this-><hljs prop>hash</hljs>($bottomRightPoint),
        ($point-><hljs prop>x</hljs> - $bottomLeftPoint-><hljs prop>x</hljs>) / ($bottomRightPoint-><hljs prop>x</hljs> - $bottomLeftPoint-><hljs prop>x</hljs>),
    );

    $noise = <hljs prop>lerp</hljs>(
        $a,
        $b,
        ($point-><hljs prop>y</hljs> - $topLeftPoint-><hljs prop>y</hljs>) / ($bottomLeftPoint-><hljs prop>y</hljs> - $topLeftPoint-><hljs prop>y</hljs>),
    );
}
```

Note that there's some repetition in our code that we could get rid of. But I prefer explicitly making all four edge points for clarity. Take a look at the result though:

![](/resources/img/blog/game/game-14.png)

This looks much smoother! Let's apply our colours:

![](/resources/img/blog/game/game-15.png)

Hm. You can probably see where we're going, but I still think these lines are far too… rough. Luckily, there are two more tricks we can apply! First, instead of using a plain lerp function, we can apply a so-called "[shaping function](https://thebookofshaders.com/05/)" to our fraction. With this shaping function, we can manipulate our fraction before passing it to the lerp function. By default, our fraction will have a linear value — it's the distance from any given point to the starting edge:

![](/resources/img/blog/game/game-22.png)

But by applying a function to our fraction, we can manipulate it so that the values closer to the edges are even more smooth.

![](/resources/img/blog/game/game-23.png)

We could use whatever function we'd want. For our case I'll use a shaping function called `smoothstep`, which smooths edges.

```php
function smooth(<hljs type>float</hljs> $a, <hljs type>float</hljs> $b, <hljs type>float</hljs> $fraction): <hljs type>float</hljs>
{
    $smoothstep = function (<hljs type>float</hljs> $fraction): <hljs type>float</hljs> {
        $v1 = $fraction * $fraction;
        $v2 = 1.0  - (1.0 - $fraction) * (1.0 -$fraction);

        return <hljs prop>lerp</hljs>($v1, $v2, $fraction);
    };

    return <hljs prop>lerp</hljs>($a, $b, $smoothstep($fraction));
}
```

The difference is subtle, but it's a little bit better.

![](/resources/img/blog/game/game-16.png)

The second trick is to apply a new layer of noise. This one shouldn't be as random as our first one though. We'll use a simple circular pattern, and apply it as a height map on our existing noise. The further a pixel is from the center, the smaller its value:

```php
private function circularNoise(<hljs type>int</hljs> $totalWidth, <hljs type>int</hljs> $totalHeight, <hljs type>Point</hljs> $point): <hljs type>float</hljs>
{
    $middleX = $totalWidth / 2;
    $middleY = $totalHeight / 2;

    $distanceFromMiddle = <hljs prop>sqrt</hljs>(
        <hljs prop>pow</hljs>(($point-><hljs prop>x</hljs> - $middleX), 2)
        + <hljs prop>pow</hljs>(($point-><hljs prop>y</hljs> - $middleY), 2)
    );

    $maxDistanceFromMiddle = <hljs prop>sqrt</hljs>(
        <hljs prop>pow</hljs>(($totalWidth - $middleX), 2)
        + <hljs prop>pow</hljs>(($totalHeight - $middleY), 2)
    );

    return 1 - ($distanceFromMiddle / $maxDistanceFromMiddle) + 0.3;
}
```

This is the pattern on its own:

![](/resources/img/blog/game/game-17.png)

And now we combine this pattern with our existing noise, which is as easy as multiplying them:


```php
final <hljs keyword>readonly</hljs> class Noise
{
    public function __construct(
        <hljs keyword>private</hljs> <hljs type>int</hljs> <hljs prop>$seed</hljs>,
    ) {}
    
    public function generate(<hljs type>Point</hljs> $point): float
    {
        return $this-><hljs prop>baseNoise</hljs>($point) 
             * $this-><hljs prop>circularNoise</hljs>($point);
    }
}
```

Here's the result:

![](/resources/img/blog/game/game-18.png)

This looks a lot better! Thanks to our circular pattern, the middle portion of our map is raised, while the outer portions are lowered. It creates a neat island look. Let's try out some seeds to see the difference between them:

![](/resources/img/blog/game/game-24.png)
![](/resources/img/blog/game/game-26.png)
![](/resources/img/blog/game/game-25.png)

Pretty nice! But we're far from done: we'll want to add different areas on our map: forests, plains, mountains, vegetation, …. Simply using a `<hljs keyword>match</hljs>` in our `<hljs prop>drawPixel</hljs>` method won't suffice anymore. 

## Improved drawing

Let's make an interface `<hljs type>Biome</hljs>`, which will determine our pixel color, and can determine what kind of vegetation should be added. We'll also represent pixels as a proper value object. 

```php
interface Biome
{
    public function getPixelColor(<hljs type>Pixel</hljs> $pixel): <hljs type>string</hljs>;
}
```

Let's add seas and plains first.


```php
final <hljs keyword>readonly</hljs> class SeaBiome implements Biome
{
    public function getPixelColor(<hljs type>Pixel</hljs> $pixel): <hljs type>string</hljs>
    {
        $base = $pixel-><hljs prop>value</hljs>;

        while ($base < 0.25) {
            $base += 0.01;
        }

        $r = <hljs prop>hex</hljs>($base / 3);
        $g = <hljs prop>hex</hljs>($base / 3);
        $b = <hljs prop>hex</hljs>($base);

        return "#{$r}{$g}{$b}";
    }
}

final <hljs keyword>readonly</hljs> class PlainsBiome implements Biome
{
    public function getPixelColor(<hljs type>Pixel</hljs> $pixel): <hljs type>string</hljs>
    {
        $g = <hljs prop>hex</hljs>($pixel-><hljs prop>value</hljs>);
        $b = <hljs prop>hex</hljs>($pixel-><hljs prop>value</hljs> / 4);

        return "#00{$g}{$b}";
    }
}
```

Depending on a pixel's biome, we'll use its noise to generate a different kind of color.
In our `<hljs prop>drawPixel</hljs>` function, we can now make some changes:

```php
function drawPixel(<hljs type>Pixel</hljs> $pixel): string
{
    $biome = <hljs type>BiomeFactory</hljs>::<hljs prop>for</hljs>($pixel);
    
    $color = $biome-><hljs prop>getPixelColor</hljs>($pixel);
    
    <hljs keyword>return</hljs> <<<HTML
    <<hljs keyword>div</hljs> <hljs prop>style</hljs>="
        <hljs prop>--x</hljs>: {$x}; 
        <hljs prop>--y</hljs>: {$y};
        <hljs prop>--pixel-color</hljs>: {$color};
    "></<hljs keyword>div</hljs>>
    HTML;
}
```

For now, our <hljs type>BiomeFactory</hljs> will only take a pixel's value into account to determine the biome. We could add other conditions later. 

```php
final <hljs keyword>readonly</hljs> class BiomeFactory
{
    public static function for(<hljs type>Pixel</hljs> $pixel): Biome
    {
        return <hljs keyword>match</hljs>(true) {
            $pixel-><hljs prop>value</hljs> < 0.6 => new <hljs type>SeaBiome</hljs>(),
            default => new <hljs type>PlainsBiome</hljs>(),
        };
    }
}
```

It still works:

![](/resources/img/blog/game/game-27.png)

Let's go ahead and add all biomes now:

```php
final <hljs keyword>readonly</hljs> class BiomeFactory
{
    public static function make(<hljs type>Pixel</hljs> $pixel): Biome
    {
        return <hljs keyword>match</hljs>(true) {
            $pixel-><hljs prop>value</hljs> < 0.4 => new <hljs type>SeaBiome</hljs>(),
            $pixel-><hljs prop>value</hljs> >= 0.4 && $pixel-><hljs prop>value</hljs> < 0.44 => new <hljs type>BeachBiome</hljs>(),
            $pixel-><hljs prop>value</hljs> >= 0.6 && $pixel-><hljs prop>value</hljs> < 0.8 => new <hljs type>ForestBiome</hljs>(),
            $pixel-><hljs prop>value</hljs> >= 0.8 => new <hljs type>MountainBiome</hljs>(),
            default => new <hljs type>PlainsBiome</hljs>(),
        };
    }
}
```

Note that I also decided to change the sea level: from 0.6 to 0.4, so the map looks a bit different now. Take a look:

![](/resources/img/blog/game/game-28.png)

Not bad, right? But this is far from a finished game — in fact, this is only the very first step: we'll need a way of interacting with this map, we'll need to define some form of gameplay. Maybe you remember the intro? I mentioned resource gathering. I imagine this game to be some kind of cookie-clicker style game: the more resources you gather, the more you can advance in the tech tree, the more resources you can gather, … 

Anyway, I've done a lot more work on this game already: I actually started this project as an experiment to explore the limits of [Laravel Livewire](https://laravel-livewire.com/), so interactivity and gameplay were the primary focus. I've explained the basic concepts already [on my YouTube channel](https://www.youtube.com/watch?v=lnWrM6RXNak) in two videos. I'm also working on a third video where I discuss how I added interaction to this particular game board, as well as the problems I ran in to (there are a bunch of caveats I haven't mentioned yet in this blog post).

So, if you want to follow along, make sure to [subscribe on YouTube](https://www.youtube.com/@phpannotated) — I hope to make the third and final video of this series soon. Alternatively, you can [subscribe to my mailing list](/mail), where I'll send you an update as well.

In the meantime, you can watch the first two parts of this series; and don't forget to subscribe! 

<p>
    <iframe width="560" height="400" 
        src="https://www.youtube.com/embed/lnWrM6RXNak" 
        frameborder="0" 
        allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" 
        allowfullscreen>
    </iframe>
</p>
